// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/hellofresh/goengine/driver/sql (interfaces: NotificationQueuer)

// Package sql is a generated GoMock package.
package sql

import (
	context "context"
	gomock "github.com/golang/mock/gomock"
	sql "github.com/hellofresh/goengine/driver/sql"
	reflect "reflect"
)

// NotificationQueuer is a mock of NotificationQueuer interface
type NotificationQueuer struct {
	ctrl     *gomock.Controller
	recorder *NotificationQueuerMockRecorder
}

// NotificationQueuerMockRecorder is the mock recorder for NotificationQueuer
type NotificationQueuerMockRecorder struct {
	mock *NotificationQueuer
}

// NewNotificationQueuer creates a new mock instance
func NewNotificationQueuer(ctrl *gomock.Controller) *NotificationQueuer {
	mock := &NotificationQueuer{ctrl: ctrl}
	mock.recorder = &NotificationQueuerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *NotificationQueuer) EXPECT() *NotificationQueuerMockRecorder {
	return m.recorder
}

// Close mocks base method
func (m *NotificationQueuer) Close() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Close")
}

// Close indicates an expected call of Close
func (mr *NotificationQueuerMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*NotificationQueuer)(nil).Close))
}

// IsEmpty mocks base method
func (m *NotificationQueuer) Empty() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsEmpty")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsEmpty indicates an expected call of IsEmpty
func (mr *NotificationQueuerMockRecorder) Empty() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsEmpty", reflect.TypeOf((*NotificationQueuer)(nil).Empty))
}

// Next mocks base method
func (m *NotificationQueuer) Next(arg0 context.Context) (*sql.ProjectionNotification, bool) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Next", arg0)
	ret0, _ := ret[0].(*sql.ProjectionNotification)
	ret1, _ := ret[1].(bool)
	return ret0, ret1
}

// Next indicates an expected call of Next
func (mr *NotificationQueuerMockRecorder) Next(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Next", reflect.TypeOf((*NotificationQueuer)(nil).Next), arg0)
}

// Open mocks base method
func (m *NotificationQueuer) Open() chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open")
	ret0, _ := ret[0].(chan struct{})
	return ret0
}

// Open indicates an expected call of Open
func (mr *NotificationQueuerMockRecorder) Open() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*NotificationQueuer)(nil).Open))
}

// Queue mocks base method
func (m *NotificationQueuer) Queue(arg0 context.Context, arg1 *sql.ProjectionNotification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Queue", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Queue indicates an expected call of Queue
func (mr *NotificationQueuerMockRecorder) Queue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Queue", reflect.TypeOf((*NotificationQueuer)(nil).Queue), arg0, arg1)
}

// ReQueue mocks base method
func (m *NotificationQueuer) ReQueue(arg0 context.Context, arg1 *sql.ProjectionNotification) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReQueue", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReQueue indicates an expected call of ReQueue
func (mr *NotificationQueuerMockRecorder) ReQueue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReQueue", reflect.TypeOf((*NotificationQueuer)(nil).ReQueue), arg0, arg1)
}
